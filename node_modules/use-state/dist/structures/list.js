'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

const Collection = require('./collection');
const parseType = require('./parse-type');

class List extends Collection {
  // the literal string represents Type

  static setElementType(Type) {
    const typeInfo = parseType(Type);
    const type = typeInfo.type,
          invalid = typeInfo.invalid;

    if (type === 'map' || type === 'list' || invalid) throw new TypeError(`Invalid element type ${ type } in list`);

    this.type = type;
    this.Type = typeInfo.Type;
  } // the class(constructor function) of element type


  static derive(SubClass) {
    SubClass.Type = null;
    SubClass.type = null;
    SubClass.setElementType = this.setElementType;
    if (!SubClass.derive) SubClass.derive = this.derive;
  }

  init() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    super.init(options);
    const store = options.store;
    var _options$value = options.value;
    const value = _options$value === undefined ? [] : _options$value;

    // initiate

    var _constructor = this.constructor;
    const type = _constructor.type,
          Type = _constructor.Type;

    if (type === 'model') Type.bindStore(store);

    this._data = value.map((element, index) => this.parseInitKeyValue(index, element));
  }

  keys() {
    return Object.keys(this._data);
  }

  has(key) {
    // eslint-disable-line class-methods-use-this
    const type = typeof key;
    if (type === 'string') {
      key = parseInt(key, 10);
      if (isNaN(key)) return false;
    } else if (typeof key !== 'number') return false;

    if (key < 0) {
      key += this._data.length;
      if (key < 0) return false;
    }
    return true;
  }

  // normalize and validate the value
  validate(key, value) {
    // eslint-disable-line class-methods-use-this
    return value;
  }

  getKeyDefinition(key) {
    // eslint-disable-line class-methods-use-this
    var _constructor2 = this.constructor;
    const type = _constructor2.type,
          Type = _constructor2.Type;

    return { type: type, Type: Type };
  }

  readKeyValue(key) {
    const len = this._data.length;
    if (key < 0) key += len;
    if (key >= len) {
      return null;
    } else {
      return super.readKeyValue(key);
    }
  }

  writeKeyValue(key, value) {
    super.writeKeyValue(key, value);

    const len = this._data.length;
    if (key < 0) key = len + key;
    if (key >= len) {
      this._data = [].concat(_toConsumableArray(this._data));
      this._data[key] = value;
    } else {
      this._data = [].concat(_toConsumableArray(this._data.slice(0, key)), [value], _toConsumableArray(this._data.slice(key + 1)));
    }
  }
}

List.Type = null;
List.type = null;
function createList(Type) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  class DerivedList extends List {}
  List.derive(DerivedList);
  DerivedList.setElementType(Type);
  Type = null;

  return DerivedList;
}

module.exports = { createList: createList, List: List };