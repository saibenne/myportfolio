{"ast":null,"code":"'use strict';\n\nconst isPlainObject = require('lodash.isplainobject');\n\n// Collection is the data type, include Map, List, Model.\n// a collection(instance) has such status:\n// 1. none: orignial data, data not changed\n// 2. cloned: a new collection, initially has same data with `none`, prepares for mutation\n// 3. changed: a new collection with changed data, based on `cloned` status\n\nclass Collection {\n  // the last exported plain json data\n\n  // under which mutation operation(from store.mutate()).\n  // if this value equals to store's mutationId, that means collection was cloned\n  // and ready for changed.\n  // the bound global store\n  constructor(options) {\n    this._store = null;\n    this._data = null;\n    this._json = null;\n    this._mutationId = null;\n    this._isChanged = false;\n    this.init(options);\n  }\n\n  // use init to do constructor work, since in some cases(see model)\n  // we need use this before super() called, which can't be applied in constructor\n\n  // whether current data is changed directly.\n  // this value don't totally represent `changed` status of collection,\n  // only if this collection is in `cloned` status.\n  // keys' value\n  init() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const store = options.store;\n    if (!store) throw new Error('Require store');\n    this._store = store;\n  }\n  isCloned() {\n    const storeMutationId = this._store.mutationId;\n    return storeMutationId && this._mutationId === storeMutationId;\n  }\n  isChanged() {\n    if (this.isCloned()) {\n      return this._isChanged;\n    }\n    return false;\n  }\n  clone() {\n    const mutationId = this._store.mutationId;\n    if (!mutationId) {\n      throw new Error('Can\\'t change the state outside store.mutate()');\n    }\n\n    // already cloned\n    if (this._mutationId === mutationId) return this;\n\n    // now, should clone a new collection\n\n    // remove last mutation operation mark\n    if (this._mutationId) {\n      this._mutationId = null;\n      this._isChanged = false;\n    }\n\n    // create a new collection with mutation operation id\n    const newThis = Object.create(this.constructor.prototype);\n    newThis._mutationId = mutationId; // eslint-disable-line no-underscore-dangle\n    newThis._isChanged = false; // eslint-disable-line no-underscore-dangle\n\n    // refer same data from old collection\n    newThis._store = this._store; // eslint-disable-line no-underscore-dangle\n    newThis._isRoot = this._isRoot; // eslint-disable-line no-underscore-dangle\n    newThis._data = this._data; // eslint-disable-line no-underscore-dangle\n    newThis._json = this._json; // eslint-disable-line no-underscore-dangle\n\n    return newThis;\n  }\n  keys() {// eslint-disable-line class-methods-use-this\n  }\n  has(key) {\n    // eslint-disable-line class-methods-use-this\n    return false;\n  }\n\n  // normalize and validate the value, only for literal key\n  validate(key, value) {\n    // eslint-disable-line class-methods-use-this\n    return value;\n  }\n  set(keysPath, value) {\n    if (!keysPath && keysPath !== 0) throw new Error('Require key or keys path');\n    if (!Array.isArray(keysPath)) keysPath = [keysPath];\n    const key = keysPath[0];\n    if (key === null || typeof key === 'undefined') throw new Error('Require key or keys path');\n    if (!this.has(key)) throw new Error(`Nonexistent key ${key}`);\n    var _getKeyDefinition = this.getKeyDefinition(key);\n    const type = _getKeyDefinition.type,\n      Type = _getKeyDefinition.Type;\n    const isCollType = type === 'list' || type === 'map' || type === 'model';\n    const oldValue = this.readKeyValue(key);\n    if (keysPath.length > 1) {\n      // try to call set recursively\n      if (!isCollType) throw new Error(`Can't call set method on the value of key ${key}`);\n      value = oldValue.set(keysPath.slice(1), value);\n    } else if (typeof value === 'function') {\n      // update key value in callback\n      const cb = value;\n      if (isCollType) {\n        value = oldValue.clone();\n        cb(value); // not require return value, since we already have the mutation copy\n      } else {\n        // normal literal value, like number/string/boolean\n        value = cb(oldValue);\n      }\n    }\n    if (isCollType) {\n      if (!(value instanceof Type)) value = new Type({\n        store: this._store,\n        value: value\n      });else if (oldValue && !value.isChanged()) return this;\n    } else {\n      if (value === oldValue) return this;\n      value = this.validate(key, value);\n    }\n    const cloned = this.clone();\n    cloned.writeKeyValue(key, value);\n    return cloned;\n  }\n  get(keysPath) {\n    if (!keysPath && keysPath !== 0) throw new Error('Require key or keys path');\n    if (!Array.isArray(keysPath)) keysPath = [keysPath];\n    const key = keysPath[0];\n    if (key === null || typeof key === 'undefined') throw new Error('Require key or keys path');\n    if (!this.has(key)) throw new Error(`Nonexistent key ${key}`);\n    var _getKeyDefinition2 = this.getKeyDefinition(key);\n    const type = _getKeyDefinition2.type;\n    const isCollType = type === 'list' || type === 'map' || type === 'model';\n    const value = this.readKeyValue(key);\n    if (keysPath.length > 1) {\n      if (!isCollType) throw new Error(`Can't call get method on the value of key ${key}`);\n      return value.get(keysPath.slice(1));\n    } else {\n      if (typeof value === 'undefined') return null;\n      return value;\n    }\n  }\n\n  // get key's definition, mainly for type and Type properties\n  getKeyDefinition(key) {\n    // eslint-disable-line class-methods-use-this\n    return {};\n  }\n\n  // read the value at the key from the data\n  readKeyValue(key) {\n    const value = this._data[key];\n    if (!value) return value;\n\n    // if under mutation and key is model, always return the latest record value\n    if (this._store.mutationId) {\n      var _getKeyDefinition3 = this.getKeyDefinition(key);\n      const type = _getKeyDefinition3.type,\n        Type = _getKeyDefinition3.Type;\n      if (type === 'model') {\n        return Type.findById(value.getId()) || null;\n      }\n    }\n    return value;\n  }\n\n  // write the value at the key to the data\n  // derived class should override this method to do the actual write\n  writeKeyValue(key, value) {\n    this._isChanged = true;\n    this._json = null;\n    // write the key value to data in derived class\n  }\n  parseInitKeyValue(key, value) {\n    const store = this._store;\n    var _getKeyDefinition4 = this.getKeyDefinition(key);\n    const type = _getKeyDefinition4.type,\n      Type = _getKeyDefinition4.Type;\n    if (type === 'map') {\n      if (!value) {\n        return new Type({\n          store: store\n        });\n      } else if (value instanceof Type) {\n        return value;\n      } else if (isPlainObject(value)) {\n        return new Type({\n          store: store,\n          value: value\n        });\n      } else {\n        throw new Error(`Invalid initital value for key ${key}`);\n      }\n    } else if (type === 'list') {\n      if (!value) {\n        return new Type({\n          store: store\n        });\n      } else if (value instanceof Type) {\n        return value;\n      } else if (Array.isArray(value)) {\n        return new Type({\n          store: store,\n          value: value\n        });\n      } else {\n        throw new Error(`Invalid initital value for key ${key}`);\n      }\n    } else if (type === 'model') {\n      Type.bindStore(store);\n      if (!value) {\n        return null;\n      } else if (value instanceof Type) {\n        return value;\n      } else if (isPlainObject(value)) {\n        // always reuse the existent record on initing,\n        // thus records with same id will be treated as same records,\n        // to avoid circular-reference models creating multiple objects with same data\n        let record = Type.findById(value.id);\n        if (!record) record = new Type({\n          store: store,\n          value: value\n        });\n        return record;\n      } else {\n        throw new Error(`Invalid initital value for key ${key}`);\n      }\n    } else if (value === null || typeof value === 'undefined') {\n      return null;\n    } else {\n      return this.validate(key, value);\n    }\n  }\n\n  // Since a model record may be refered on many positions, when we change the record,\n  // all refered nodes and their ancestors should also be mutated.\n  // That's the called `Mutation Bubble`.\n  // This function will return a new cloned and changed object if the underlying model mutated.\n  bubbleModelMutation() {\n    const keys = this.keys(),\n      len = keys.length;\n    if (len <= 0) return;\n    let obj = this;\n    keys.forEach(key => {\n      const value = this._data[key]; // same to obj._data[key];\n      if (!value) return;\n      var _getKeyDefinition5 = this.getKeyDefinition(key);\n      const type = _getKeyDefinition5.type,\n        Type = _getKeyDefinition5.Type;\n      if (type === 'model') {\n        let record = Type.findById(value.getId());\n        if (record) {\n          // use `$checked` to break circular relational records loop.\n          if (record.$checked !== this._store.mutationId) {\n            record.$checked = this._store.mutationId;\n            const newValue = record.bubbleModelMutation();\n            if (newValue) record = newValue;\n          }\n        }\n        if (record !== value) {\n          // record changed(deleted or updated)\n          // next lines are equal to but faster than `this.set(key, record)`\n          obj = obj.clone();\n          obj.writeKeyValue(key, record);\n        }\n      } else if (type === 'map' || type === 'list') {\n        const newValue = value.bubbleModelMutation();\n        if (newValue) {\n          // cloned and changed\n          // next lines are equal to but faster than `this.set(key, newValue)`\n          obj = obj.clone();\n          obj.writeKeyValue(key, newValue);\n        }\n      }\n    });\n    if (obj === this) return null;\n    return obj;\n  }\n\n  // user should not call toJSON(true), only for internal usage\n  toJSON(dontCheckMutatedByModel) {\n    if (this._json) return this._json;\n\n    // assign this._json first to avoid infinite loop on circular invoke\n    const data = this._json = Array.isArray(this._data) ? [] : {};\n    this.keys().forEach(key => {\n      const value = this.readKeyValue(key);\n      if (!value) {\n        data[key] = value;\n        return;\n      }\n      var _getKeyDefinition6 = this.getKeyDefinition(key);\n      const type = _getKeyDefinition6.type;\n      if (type === 'map' || type === 'list' || type === 'model') {\n        data[key] = value.toJSON(true);\n      } else {\n        data[key] = value;\n      }\n    });\n    return data;\n  }\n}\nmodule.exports = Collection;","map":{"version":3,"names":["isPlainObject","require","Collection","constructor","options","_store","_data","_json","_mutationId","_isChanged","init","arguments","length","undefined","store","Error","isCloned","storeMutationId","mutationId","isChanged","clone","newThis","Object","create","prototype","_isRoot","keys","has","key","validate","value","set","keysPath","Array","isArray","_getKeyDefinition","getKeyDefinition","type","Type","isCollType","oldValue","readKeyValue","slice","cb","cloned","writeKeyValue","get","_getKeyDefinition2","_getKeyDefinition3","findById","getId","parseInitKeyValue","_getKeyDefinition4","bindStore","record","id","bubbleModelMutation","len","obj","forEach","_getKeyDefinition5","$checked","newValue","toJSON","dontCheckMutatedByModel","data","_getKeyDefinition6","module","exports"],"sources":["C:/Users/sai/Desktop/Portfolio/template1/node_modules/use-state/dist/structures/collection.js"],"sourcesContent":["'use strict';\n\nconst isPlainObject = require('lodash.isplainobject');\n\n// Collection is the data type, include Map, List, Model.\n// a collection(instance) has such status:\n// 1. none: orignial data, data not changed\n// 2. cloned: a new collection, initially has same data with `none`, prepares for mutation\n// 3. changed: a new collection with changed data, based on `cloned` status\n\nclass Collection {\n  // the last exported plain json data\n\n  // under which mutation operation(from store.mutate()).\n  // if this value equals to store's mutationId, that means collection was cloned\n  // and ready for changed.\n  // the bound global store\n  constructor(options) {\n    this._store = null;\n    this._data = null;\n    this._json = null;\n    this._mutationId = null;\n    this._isChanged = false;\n\n    this.init(options);\n  }\n\n  // use init to do constructor work, since in some cases(see model)\n  // we need use this before super() called, which can't be applied in constructor\n\n\n  // whether current data is changed directly.\n  // this value don't totally represent `changed` status of collection,\n  // only if this collection is in `cloned` status.\n  // keys' value\n  init() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const store = options.store;\n\n    if (!store) throw new Error('Require store');\n    this._store = store;\n  }\n\n  isCloned() {\n    const storeMutationId = this._store.mutationId;\n    return storeMutationId && this._mutationId === storeMutationId;\n  }\n\n  isChanged() {\n    if (this.isCloned()) {\n      return this._isChanged;\n    }\n    return false;\n  }\n\n  clone() {\n    const mutationId = this._store.mutationId;\n    if (!mutationId) {\n      throw new Error('Can\\'t change the state outside store.mutate()');\n    }\n\n    // already cloned\n    if (this._mutationId === mutationId) return this;\n\n    // now, should clone a new collection\n\n    // remove last mutation operation mark\n    if (this._mutationId) {\n      this._mutationId = null;\n      this._isChanged = false;\n    }\n\n    // create a new collection with mutation operation id\n    const newThis = Object.create(this.constructor.prototype);\n    newThis._mutationId = mutationId; // eslint-disable-line no-underscore-dangle\n    newThis._isChanged = false; // eslint-disable-line no-underscore-dangle\n\n    // refer same data from old collection\n    newThis._store = this._store; // eslint-disable-line no-underscore-dangle\n    newThis._isRoot = this._isRoot; // eslint-disable-line no-underscore-dangle\n    newThis._data = this._data; // eslint-disable-line no-underscore-dangle\n    newThis._json = this._json; // eslint-disable-line no-underscore-dangle\n\n    return newThis;\n  }\n\n  keys() {// eslint-disable-line class-methods-use-this\n\n  }\n\n  has(key) {\n    // eslint-disable-line class-methods-use-this\n    return false;\n  }\n\n  // normalize and validate the value, only for literal key\n  validate(key, value) {\n    // eslint-disable-line class-methods-use-this\n    return value;\n  }\n\n  set(keysPath, value) {\n    if (!keysPath && keysPath !== 0) throw new Error('Require key or keys path');\n    if (!Array.isArray(keysPath)) keysPath = [keysPath];\n\n    const key = keysPath[0];\n    if (key === null || typeof key === 'undefined') throw new Error('Require key or keys path');\n    if (!this.has(key)) throw new Error(`Nonexistent key ${ key }`);\n\n    var _getKeyDefinition = this.getKeyDefinition(key);\n\n    const type = _getKeyDefinition.type,\n          Type = _getKeyDefinition.Type;\n\n    const isCollType = type === 'list' || type === 'map' || type === 'model';\n    const oldValue = this.readKeyValue(key);\n\n    if (keysPath.length > 1) {\n      // try to call set recursively\n      if (!isCollType) throw new Error(`Can't call set method on the value of key ${ key }`);\n      value = oldValue.set(keysPath.slice(1), value);\n    } else if (typeof value === 'function') {\n      // update key value in callback\n      const cb = value;\n      if (isCollType) {\n        value = oldValue.clone();\n        cb(value); // not require return value, since we already have the mutation copy\n      } else {\n        // normal literal value, like number/string/boolean\n        value = cb(oldValue);\n      }\n    }\n\n    if (isCollType) {\n      if (!(value instanceof Type)) value = new Type({ store: this._store, value: value });else if (oldValue && !value.isChanged()) return this;\n    } else {\n      if (value === oldValue) return this;\n      value = this.validate(key, value);\n    }\n\n    const cloned = this.clone();\n    cloned.writeKeyValue(key, value);\n\n    return cloned;\n  }\n\n  get(keysPath) {\n    if (!keysPath && keysPath !== 0) throw new Error('Require key or keys path');\n    if (!Array.isArray(keysPath)) keysPath = [keysPath];\n\n    const key = keysPath[0];\n    if (key === null || typeof key === 'undefined') throw new Error('Require key or keys path');\n    if (!this.has(key)) throw new Error(`Nonexistent key ${ key }`);\n\n    var _getKeyDefinition2 = this.getKeyDefinition(key);\n\n    const type = _getKeyDefinition2.type;\n\n    const isCollType = type === 'list' || type === 'map' || type === 'model';\n    const value = this.readKeyValue(key);\n\n    if (keysPath.length > 1) {\n      if (!isCollType) throw new Error(`Can't call get method on the value of key ${ key }`);\n      return value.get(keysPath.slice(1));\n    } else {\n      if (typeof value === 'undefined') return null;\n      return value;\n    }\n  }\n\n  // get key's definition, mainly for type and Type properties\n  getKeyDefinition(key) {\n    // eslint-disable-line class-methods-use-this\n    return {};\n  }\n\n  // read the value at the key from the data\n  readKeyValue(key) {\n    const value = this._data[key];\n    if (!value) return value;\n\n    // if under mutation and key is model, always return the latest record value\n    if (this._store.mutationId) {\n      var _getKeyDefinition3 = this.getKeyDefinition(key);\n\n      const type = _getKeyDefinition3.type,\n            Type = _getKeyDefinition3.Type;\n\n      if (type === 'model') {\n        return Type.findById(value.getId()) || null;\n      }\n    }\n\n    return value;\n  }\n\n  // write the value at the key to the data\n  // derived class should override this method to do the actual write\n  writeKeyValue(key, value) {\n    this._isChanged = true;\n    this._json = null;\n    // write the key value to data in derived class\n  }\n\n  parseInitKeyValue(key, value) {\n    const store = this._store;\n\n    var _getKeyDefinition4 = this.getKeyDefinition(key);\n\n    const type = _getKeyDefinition4.type,\n          Type = _getKeyDefinition4.Type;\n\n    if (type === 'map') {\n      if (!value) {\n        return new Type({ store: store });\n      } else if (value instanceof Type) {\n        return value;\n      } else if (isPlainObject(value)) {\n        return new Type({ store: store, value: value });\n      } else {\n        throw new Error(`Invalid initital value for key ${ key }`);\n      }\n    } else if (type === 'list') {\n      if (!value) {\n        return new Type({ store: store });\n      } else if (value instanceof Type) {\n        return value;\n      } else if (Array.isArray(value)) {\n        return new Type({ store: store, value: value });\n      } else {\n        throw new Error(`Invalid initital value for key ${ key }`);\n      }\n    } else if (type === 'model') {\n      Type.bindStore(store);\n\n      if (!value) {\n        return null;\n      } else if (value instanceof Type) {\n        return value;\n      } else if (isPlainObject(value)) {\n        // always reuse the existent record on initing,\n        // thus records with same id will be treated as same records,\n        // to avoid circular-reference models creating multiple objects with same data\n        let record = Type.findById(value.id);\n\n        if (!record) record = new Type({ store: store, value: value });\n        return record;\n      } else {\n        throw new Error(`Invalid initital value for key ${ key }`);\n      }\n    } else if (value === null || typeof value === 'undefined') {\n      return null;\n    } else {\n      return this.validate(key, value);\n    }\n  }\n\n  // Since a model record may be refered on many positions, when we change the record,\n  // all refered nodes and their ancestors should also be mutated.\n  // That's the called `Mutation Bubble`.\n  // This function will return a new cloned and changed object if the underlying model mutated.\n  bubbleModelMutation() {\n    const keys = this.keys(),\n          len = keys.length;\n    if (len <= 0) return;\n\n    let obj = this;\n    keys.forEach(key => {\n      const value = this._data[key]; // same to obj._data[key];\n      if (!value) return;\n\n      var _getKeyDefinition5 = this.getKeyDefinition(key);\n\n      const type = _getKeyDefinition5.type,\n            Type = _getKeyDefinition5.Type;\n\n      if (type === 'model') {\n        let record = Type.findById(value.getId());\n        if (record) {\n          // use `$checked` to break circular relational records loop.\n          if (record.$checked !== this._store.mutationId) {\n            record.$checked = this._store.mutationId;\n            const newValue = record.bubbleModelMutation();\n            if (newValue) record = newValue;\n          }\n        }\n        if (record !== value) {\n          // record changed(deleted or updated)\n          // next lines are equal to but faster than `this.set(key, record)`\n          obj = obj.clone();\n          obj.writeKeyValue(key, record);\n        }\n      } else if (type === 'map' || type === 'list') {\n        const newValue = value.bubbleModelMutation();\n        if (newValue) {\n          // cloned and changed\n          // next lines are equal to but faster than `this.set(key, newValue)`\n          obj = obj.clone();\n          obj.writeKeyValue(key, newValue);\n        }\n      }\n    });\n\n    if (obj === this) return null;\n    return obj;\n  }\n\n  // user should not call toJSON(true), only for internal usage\n  toJSON(dontCheckMutatedByModel) {\n    if (this._json) return this._json;\n\n    // assign this._json first to avoid infinite loop on circular invoke\n    const data = this._json = Array.isArray(this._data) ? [] : {};\n\n    this.keys().forEach(key => {\n      const value = this.readKeyValue(key);\n      if (!value) {\n        data[key] = value;\n        return;\n      }\n\n      var _getKeyDefinition6 = this.getKeyDefinition(key);\n\n      const type = _getKeyDefinition6.type;\n\n      if (type === 'map' || type === 'list' || type === 'model') {\n        data[key] = value.toJSON(true);\n      } else {\n        data[key] = value;\n      }\n    });\n\n    return data;\n  }\n}\n\nmodule.exports = Collection;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}